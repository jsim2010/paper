//! Implements the interface between the user and the application.
//!
//! The user is able to provide input via any of the following methods:
//! - Environment variables of the terminal running the command - $HOME, $CWD.
//! - An argument given with the command; this allows all processing of arguments to be performed within the main application loop.
//! - A terminal event (key press, mouse event, or size change).
//! - The config file (configs are read as input on startup - then any change to the config file is a new input).
//!
//! The application delivers the following output to the user:
//! - Failures are reported on stderr of the process running the paper command.
//! - Everything else is output on stdout of the process, and organized in the following visual manner:
//!     - The first row of the screen is the header, which displays information generated by starship.
//!     - All remaining space on the screen is primarily used for displaying the text of the currently viewed document.
//!     - If the application needs to alert the user, it may do so via a message box that will temporarily overlap the top rows of the document.
use {
    clap::ArgMatches,
    core::{convert::TryFrom, convert::TryInto, time::Duration},
    crossterm::{
        cursor::MoveTo,
        event::{self, Event},
        execute, queue,
        style::{Color, Print, ResetColor, SetBackgroundColor},
        terminal::{self, Clear, ClearType, EnterAlternateScreen, LeaveAlternateScreen},
        ErrorKind,
    },
    log::{trace, warn},
    lsp_types::{MessageType, ShowMessageParams, ShowMessageRequestParams, TextEdit},
    notify::{DebouncedEvent, RecommendedWatcher, Watcher},
    starship::{context::Context, print},
    std::{
        env, fs,
        io::{self, Stdout, Write},
        path::PathBuf,
        sync::mpsc::{self, Receiver},
    },
    thiserror::Error,
    toml::Value,
};

/// Represents the return type of all functions that may fail.
type Outcome<T> = Result<T, Fault>;

/// The [`Err`] value returned by this module.
#[derive(Debug, Error)]
pub enum Fault {
    /// Error from crossterm.
    #[error("crossterm: {0}")]
    Crossterm(#[from] ErrorKind),
    /// Error while flushing stdout.
    #[error("unable to flush stdout: {0}")]
    InvalidFlush(io::Error),
    /// Unable to find HOME path.
    #[error("unable to retrieve path of `HOME`")]
    MissingHome,
    /// An error while attempting to process the config file.
    #[error("unable to parse config file: {0}")]
    InvalidConfig(#[from] toml::de::Error),
    /// An error while attempting to retrieve the current working directory.
    #[error("invalid working directory: {0}")]
    WorkingDir(#[source] io::Error),
    /// An error while attempting to watch a path.
    #[error("unable to watch path: {0}")]
    Watch(#[source] notify::Error),
    /// An error while creating the watcher.
    #[error("unable to create watcher: {0}")]
    CreateWatcher(#[source] notify::Error),
}

/// The user interface provided by a terminal.
pub(crate) struct Terminal {
    /// The output of the application.
    out: Stdout,
    /// If `Terminal` has been initialized.
    is_init: bool,
    /// The current configuration of the application.
    config: Config,
    /// Configs that have been input.
    ///
    /// Command arguments are viewed as config input so that all processing of arguments is performed within the main application loop.
    changed_settings: Vec<Setting>,
    /// Number of columns provided by terminal.
    columns: u16,
    /// Number of rows provided by terminal.
    rows: u16,
    /// The index of the first line of the document that may be displayed.
    first_line: u64,
    /// The grid of `chars` that represent the terminal.
    grid: Vec<String>,
    /// The number of lines currrently covered by an alert.
    alert_line_count: usize,
    /// Notifies `self` of any events on the watched path.
    watcher: Option<RecommendedWatcher>,
    /// Receives events generated by `watcher`.
    notify_rx: Option<Receiver<DebouncedEvent>>,
    /// The working directory of the application.
    working_dir: PathBuf,
}

impl Terminal {
    /// Initializes the terminal user interface.
    pub(crate) fn init(&mut self, arguments: Arguments) -> Outcome<()> {
        let (columns, rows) = terminal::size()?;
        self.columns = columns;
        self.rows = rows;

        for _ in 0..rows {
            self.grid.push(String::default());
        }

        let (tx, rx) = mpsc::channel();

        let mut watcher =
            notify::watcher(tx, Duration::from_secs(0)).map_err(Fault::CreateWatcher)?;
        watcher
            .watch(Config::path()?, notify::RecursiveMode::NonRecursive)
            .map_err(Fault::Watch)?;
        self.watcher = Some(watcher);
        self.notify_rx = Some(rx);
        self.add_config_updates()?;

        self.working_dir = env::current_dir().map_err(Fault::WorkingDir)?;

        if let Some(file) = arguments.file {
            self.changed_settings.push(Setting::File(file));
        }

        // Store all previous terminal output.
        execute!(self.out, EnterAlternateScreen)?;
        self.is_init = true;
        Ok(())
    }

    /// Applies `change` to the output.
    pub(crate) fn apply(&mut self, change: Change) -> Outcome<()> {
        match change {
            Change::Text { edits, is_wrapped } => {
                for edit in edits {
                    let mut lines = edit
                        .new_text
                        .lines()
                        .skip(
                            self.first_line
                                .saturating_sub(edit.range.start.line)
                                .try_into()
                                .unwrap_or(usize::max_value()),
                        )
                        .take(
                            edit.range
                                .end
                                .line
                                .saturating_sub(edit.range.start.line)
                                .try_into()
                                .unwrap_or(usize::max_value()),
                        )
                        .collect::<Vec<&str>>()
                        .into_iter();
                    let mut row = edit
                        .range
                        .start
                        .line
                        .saturating_sub(self.first_line)
                        .try_into()
                        .unwrap_or(u16::max_value());

                    while row < self.rows {
                        if let Some(mut line) = lines.next() {
                            let mut last_row = row;

                            if is_wrapped {
                                last_row = last_row.saturating_add(
                                    u16::try_from(
                                        line.len()
                                            .saturating_sub(1)
                                            .wrapping_div(usize::from(self.columns)),
                                    )
                                    .unwrap_or(u16::max_value()),
                                );
                            }

                            for r in row..=last_row {
                                let printed_line = if line.len() > self.columns.into() {
                                    let split = line.split_at(self.columns.into());
                                    line = split.1;
                                    split.0
                                } else {
                                    line
                                };

                                if let Some(l) = self.grid.get_mut(usize::from(row)) {
                                    l.replace_range(.., printed_line)
                                }

                                self.print_at_row(r, printed_line, None)?;
                            }

                            row = last_row.saturating_add(1);
                        } else {
                            break;
                        }
                    }
                }
            }
            Change::Message(alert) => {
                trace!("alert: {:?} {}", alert.typ, alert.message);
                self.alert_line_count = alert.message.lines().count();
                self.print_at_row(0, &alert.message, Some(alert.typ))?;
            }
            Change::Question(question) => {
                self.alert_line_count = question.message.lines().count();
                self.print_at_row(0, &question.message, Some(question.typ))?;
            }
            Change::Reset => {
                if self.alert_line_count != 0 {
                    self.print_at_row(
                        0,
                        &self
                            .grid
                            .get(0..self.alert_line_count)
                            .unwrap_or_default()
                            .join("\n"),
                        None,
                    )?;
                    self.alert_line_count = 0;
                }
            }
        }

        // For now, must deal with fact that StarshipConfig included in Context is very difficult to edit (must edit the TOML Value). Thus for now, the starship.toml config file must be configured correctly.
        queue!(
            self.out,
            MoveTo(0, 0),
            Print(
                print::get_prompt(Context::new_with_dir(
                    ArgMatches::default(),
                    &self.working_dir
                ))
                .replace("[J", "")
            )
        )?;

        self.out.flush().map_err(Fault::InvalidFlush)
    }

    /// Adds to the queue the commands to print `s` starting at column 0 of `row`.
    fn print_at_row(
        &mut self,
        row: u16,
        s: &str,
        context: Option<MessageType>,
    ) -> crossterm::Result<()> {
        let mut r = row.saturating_add(1);

        for line in s.lines() {
            queue!(self.out, MoveTo(0, r))?;

            if let Some(t) = context {
                queue!(
                    self.out,
                    SetBackgroundColor(match t {
                        MessageType::Error => Color::Red,
                        MessageType::Warning => Color::Yellow,
                        MessageType::Info => Color::Blue,
                        MessageType::Log => Color::Grey,
                    })
                )?;
            }

            queue!(self.out, Print(line), Clear(ClearType::UntilNewLine))?;

            if context.is_some() {
                queue!(self.out, ResetColor)?;
            }

            r = r.saturating_add(1);
        }

        Ok(())
    }

    /// Checks for updates to [`Config`] and adds any changes the changed settings list.
    fn add_config_updates(&mut self) -> Outcome<()> {
        self.changed_settings.append(&mut self.config.update()?);
        Ok(())
    }

    /// Returns the input from the user.
    ///
    /// First checks for arg inputsReturns [`None`] if no input is provided.
    pub(crate) fn input(&mut self) -> Outcome<Option<Input>> {
        if let Some(notify_rx) = &self.notify_rx {
            if let Ok(event) = notify_rx.try_recv() {
                if let notify::DebouncedEvent::Write(_) = event {
                    self.add_config_updates()?;
                }
            }
        }

        // First check arg inputs, then check for key input.
        match self.changed_settings.pop() {
            Some(input) => Ok(Some(Input::Setting(input))),
            None => Ok(if event::poll(Duration::from_secs(0))? {
                Some(Input::User(event::read()?))
            } else {
                None
            }),
        }
    }
}

impl Default for Terminal {
    fn default() -> Self {
        Self {
            out: io::stdout(),
            is_init: false,
            changed_settings: Vec::default(),
            columns: 0,
            rows: 0,
            first_line: 0,
            grid: Vec::default(),
            alert_line_count: 0,
            watcher: None,
            notify_rx: None,
            config: Config::default(),
            working_dir: PathBuf::new(),
        }
    }
}

impl Drop for Terminal {
    fn drop(&mut self) {
        if self.is_init && execute!(self.out, LeaveAlternateScreen).is_err() {
            warn!("Failed to leave alternate screen");
        }
    }
}

/// Signifies any configurable parameter of the application.
#[derive(Debug)]
struct Config {
    /// If the application wraps long lines.
    wrap: bool,
}

impl Config {
    /// Updates `self` to match paper's config file, returning any changed [`Setting`]s.
    fn update(&mut self) -> Outcome<Vec<Setting>> {
        let mut settings = Vec::new();

        if let Ok(config_string) = fs::read_to_string(Self::path()?) {
            if let Value::Table(config_table) = config_string
                .parse::<Value>()
                .map_err(Fault::InvalidConfig)?
            {
                if let Some(wrap_value) = config_table.get("wrap") {
                    if let Value::Boolean(wrap) = wrap_value {
                        if self.wrap != *wrap {
                            self.wrap = *wrap;
                            settings.push(Setting::Wrap(self.wrap));
                        }
                    }
                }
            }
        }

        Ok(settings)
    }

    /// Returns the path of the config file.
    fn path() -> Outcome<PathBuf> {
        dirs::home_dir()
            .ok_or(Fault::MissingHome)
            .map(|home_dir| home_dir.join(".config/paper.toml"))
    }
}

impl Default for Config {
    fn default() -> Self {
        Self { wrap: false }
    }
}

/// Signifies a potential modification to the output of the user interface.
///
/// It is not always true that a `Change` will require a modification of the user interface output. For example, if a range of the document that is not currently displayed is changed.
#[derive(Clone, Debug, Eq, PartialEq)]
pub(crate) enum Change {
    /// Text of the current document or how it was displayed was modified.
    Text {
        /// Text that was modified.
        edits: Vec<TextEdit>,
        /// Long lines are wrapped.
        is_wrapped: bool,
    },
    /// Message will be displayed to the user.
    Message(ShowMessageParams),
    /// Message will ask question to user and get a response.
    Question(ShowMessageRequestParams),
    /// Message will be cleared.
    Reset,
}

/// Signifies settings of the application.
#[derive(Debug, Default)]
pub struct Arguments {
    /// The file to be viewed.
    file: Option<String>,
}

impl From<ArgMatches<'_>> for Arguments {
    #[must_use]
    fn from(value: ArgMatches<'_>) -> Self {
        Self {
            file: value.value_of("file").map(str::to_string),
        }
    }
}

/// Signifies a configuration.
#[derive(Clone, Debug, Eq, PartialEq)]
pub(crate) enum Setting {
    /// The file path of the document.
    File(String),
    /// If the document shall wrap long text.
    Wrap(bool),
}

/// Signifies input provided by the user.
#[derive(Clone, Debug)]
pub(crate) enum Input {
    /// User input.
    User(Event),
    /// Configuration.
    Setting(Setting),
}

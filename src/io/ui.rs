//! Implements the interface between the user and the application.
//!
//! The user is able to provide input via any of the following methods:
//! - key press
//! - mouse event
//! - size change
//!
//! The application delivers the following output to the user via stdout of the command. Output is organized in the following visual manner:
//! - The first row of the screen is the header, which displays information generated by starship.
//! - All remaining space on the screen is primarily used for displaying the text of the currently viewed document.
//! - If the application needs to alert the user, it may do so via a message box that will temporarily overlap the top rows of the document.
//! - If the application requires input from the user, it may do so via an input box that will temporarily overlap the bottom rows of the document.
pub(crate) use crossterm::event::{KeyCode as Key, KeyModifiers as Modifiers};

use {
    core::{
        cmp,
        convert::TryFrom,
        fmt::{self, Debug},
        time::Duration,
    },
    crossterm::{
        cursor::{Hide, MoveTo, RestorePosition, SavePosition},
        event::{self, Event},
        execute, queue,
        style::{Color, Print, ResetColor, SetBackgroundColor},
        terminal::{self, Clear, ClearType, EnterAlternateScreen, LeaveAlternateScreen},
        ErrorKind,
    },
    log::warn,
    lsp_types::{MessageType, Range, TextEdit, ShowMessageParams, ShowMessageRequestParams, Position},
    std::{
        io::{self, Stdout, Write},
        collections::VecDeque,
    },
    thiserror::Error,
};

/// A span of time that equal to no time.
static INSTANT: Duration = Duration::from_secs(0);

/// An error while executing or queueing a [`crossterm`] command.
///
/// [`crossterm`]: ../../crossterm/index.html
#[derive(Debug, Error)]
#[error("while executing or queueing a terminal command: {0}")]
pub struct CommandError(#[from] ErrorKind);

/// An error while flushing terminal output.
#[derive(Debug, Error)]
#[error("while flushing terminal output: {0}")]
pub struct FlushError(#[from] io::Error);

/// A user interface provided by a terminal.
pub(crate) struct Terminal {
    /// The output of the application.
    out: Stdout,
    /// The body of the screen, where all document text is displayed.
    body: Body,
}

#[allow(clippy::unused_self)] // For pull(), will be used when user interface becomes a trait.
impl Terminal {
    /// Creates a new [`Terminal`].
    pub(crate) fn new() -> Result<Self, CommandError> {
        let mut term = Self {
            out: io::stdout(),
            body: Body::default(),
        };

        // Execute failable commands after creating Terminal so that it will be dropped on failure.
        execute!(term.out, EnterAlternateScreen, Hide)?;
        Ok(term)
    }

    /// Returns input from the user.
    ///
    /// [`None`] indicates there is no input from the user.
    pub(crate) fn pull(&self) -> Result<Option<Input>, CommandError> {
        Ok(if event::poll(INSTANT)? {
            Some(event::read()?.into())
        } else {
            None
        })
    }

    pub(crate) fn open_doc(&mut self, text: &str) -> Result<(), CommandError> {
        self.body.set_text(text)
    }
    
    pub(crate) fn wrap(&mut self, is_wrapped: bool, selection: &Selection) -> Result<(), CommandError> {
        self.body.is_wrapped = is_wrapped;
        self.body.refresh(selection)
    }

    pub(crate) fn edit(&mut self, edit: TextEdit, selection: &Selection) -> Result<(), CommandError> {
        self.body.edit(edit);
        self.body.refresh(selection)
    }
    
    pub(crate) fn move_selection(&mut self, selection: &Selection) -> Result<(), CommandError> {
        self.body.refresh(selection)
    }

    pub(crate) fn set_header(&mut self, header: String) -> Result<(), CommandError> {
        queue!(self.out, SavePosition, MoveTo(0, 0), Print(header), RestorePosition).map_err(|e| e.into())
    }

    pub(crate) fn notify(&mut self, message: ShowMessageParams) -> Result<(), CommandError> {
        self.body.add_alert(&message.message, message.typ)
    }
    
    pub(crate) fn question(&mut self, request: ShowMessageRequestParams) -> Result<(), CommandError> {
        // TODO: Add implementation to use actions.
        self.body.add_alert(&request.message, request.typ)
    }

    pub(crate) fn start_intake(&mut self, title: String) -> Result<(), CommandError> {
        self.body.add_intake(title)
    }

    pub(crate) fn reset(&mut self) -> Result<(), CommandError> {
        self.body.reset()
    }

    pub(crate) fn resize(&mut self, size: Size) {
        self.body.size = size;
    }

    pub(crate) fn write(&mut self, ch: char) -> Result<(), CommandError> {
        queue!(self.out, Print(ch)).map_err(|e| e.into())
    }

    /// Flushes the terminal output.
    pub(crate) fn flush(&mut self) -> Result<(), FlushError> {
        self.out.flush().map_err(|e| e.into())
    }
}

impl Debug for Terminal {
    fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {
        write!(f, "Terminal")
    }
}

impl Drop for Terminal {
    fn drop(&mut self) {
        if execute!(self.out, LeaveAlternateScreen).is_err() {
            warn!("Failed to leave alternate screen");
        }
    }
}

/// Input generated by the user.
#[derive(Debug)]
pub(crate) enum Input {
    /// The space available for display has been resized.
    ///
    /// The parameter is the new size of the body.
    #[allow(dead_code)] // False positive.
    Resize(Size),
    /// A mouse event has occurred.
    Mouse,
    /// A key has been pressed.
    #[allow(dead_code)] // False positive.
    Key {
        /// The keycode of the key.
        key: Key,
        /// All modifier keys that were held when the key was pressed.
        modifiers: Modifiers,
    },
}

impl From<Event> for Input {
    fn from(value: Event) -> Self {
        match value {
            Event::Resize(columns, rows) => TerminalSize{ rows, columns }.into(),
            Event::Mouse(..) => Self::Mouse,
            Event::Key(key) => Self::Key {
                key: key.code,
                modifiers: key.modifiers,
            },
        }
    }
}

impl From<TerminalSize> for Input {
    fn from(value: TerminalSize) -> Self {
        Self::Resize(Size {
            // Account for header in first row.
            rows: value.rows.saturating_sub(1),
            // Windows command prompt does not print a character in the last reported column.
            columns: value.columns.saturating_sub(1),
        })
    }
}

/// The dimensions of a grid of [`char`]s.
#[derive(Clone, Debug, Eq, PartialEq)]
pub(crate) struct Size {
    /// The number of rows.
    pub(crate) rows: UiUnit,
    /// The number of columns.
    pub(crate) columns: UiUnit,
}

/// The [`Size`] of the terminal.
pub(crate) type TerminalSize = Size;

impl TerminalSize {
    /// Returns the size of the terminal.
    pub(crate) fn get() -> Self {
        match terminal::size() {
            Ok((columns, rows)) => Self {rows, columns},
            Err(e) => {
                warn!("unable to retrieve size of terminal: {}", e);
                Self::default()
            }
        }
    }
}

impl Default for TerminalSize {
    /// Returns the default size for a terminal: 20x80.
    fn default() -> Self {
        Self {
            rows: 20,
            columns: 80,
        }
    }
}

/// The type the user interface uses.
type UiUnit = u16;

/// The part of the output that displays the content of the document.
struct Body {
    /// The output of the application.
    out: Stdout,
    lines: Vec<String>,
    text: String,
    /// The number of rows currently covered by an alert.
    alert_rows: UiUnit,
    /// If the intake box is current active.
    is_intake_active: bool,
    /// The size of the body.
    size: Size,
    /// The index of the first line of the document to be displayed.
    top_line: u64,
    /// If the text is wrapped.
    is_wrapped: bool,
}

impl Body {
    fn set_text(&mut self, text: &str) -> Result<(), CommandError> {
        self.lines = text.lines().map(|line| line.to_string()).collect();
        self.text = text.to_string();
        self.refresh(&Selection::default())
    }

    fn edit(&mut self, edit: TextEdit) {
        let start = usize::try_from(edit.range.start.line).unwrap();
        let end = usize::try_from(edit.range.end.line).unwrap();
        let _ = self.lines.splice(start..end, edit.new_text.split('\n').filter(|line| !line.is_empty()).map(|line| line.to_string()));
        self.text = self.lines.join("\n");
    }

    /// Returns the length at which a line will be wrapped.
    fn wrap_length(&self) -> UiUnit {
        if self.is_wrapped {
            self.size.columns
        } else {
            UiUnit::max_value()
        }
    }

    fn refresh(&mut self, selection: &Selection) -> Result<(), CommandError> {
        let text = self.text.clone();
        let rows = Rows::new(&text, self.wrap_length());
        let last_line = selection.last_line();

        if self.top_line > selection.range.start.line {
            self.top_line = selection.range.start.line;
        }

        //if let Some(min_top_line) = rows.clone().rev().skip_while(|row| row.line > last_line).skip(self.size.rows.into()).next().map(|row| row.line.saturating_add(1)) {
        //    if self.top_line < min_top_line {
        //        self.top_line = min_top_line;
        //    }
        //}

        let mut visible_rows: Vec<Row<'_>> = rows
            .clone()
            .filter(|row| row.line >= self.top_line)
            .collect();

        while let Some(first_line_past_bottom) = visible_rows
            .get(usize::from(self.size.rows))
            .map(|row| row.line)
        {
            if last_line < first_line_past_bottom {
                break;
            } else {
                let line = visible_rows.remove(0).line;
                self.top_line = self.top_line.saturating_add(1);

                while visible_rows.get(0).map(|row| row.line) == Some(line) {
                    let _ = visible_rows.remove(0);
                }
            }
        }

        let top_line = self.top_line;

        for (index, row) in rows
            .filter(|row| row.line >= top_line)
            .enumerate()
            .take(usize::from(self.size.rows))
        {
            self.replace_line(UiUnit::try_from(index).expect("retrieving `UiUnit` from usize"), row.text, row.line == last_line)?;
        }

        queue!(self.out, Clear(ClearType::FromCursorDown)).map_err(|e| e.into())
    }

    /// Replaces line in grid at `index` with `new_line`.
    fn replace_line(&mut self, index: UiUnit, new_line: &str, is_cursor_line: bool) -> Result<(), CommandError> {
        self.print_row(
            index,
            new_line,
            if is_cursor_line {
                Some(Color::DarkGrey)
            } else {
                None
            },
        )
    }

    /// Adds an alert box over the grid.
    fn add_alert(&mut self, message: &str, context: MessageType) -> Result<(), CommandError> {
        for line in message.lines() {
            self.print_row(
                self.alert_rows,
                line,
                Some(match context {
                    MessageType::Error => Color::Red,
                    MessageType::Warning => Color::Yellow,
                    MessageType::Info => Color::Blue,
                    MessageType::Log => Color::DarkCyan,
                }),
            )?;
            self.alert_rows = self.alert_rows.saturating_add(1);
        }

        Ok(())
    }

    /// Adds an input box beginning with `prompt`
    fn add_intake(&mut self, mut prompt: String) -> Result<(), CommandError> {
        prompt.push_str(": ");
        self.print_row(self.size.rows.saturating_sub(1), &prompt, None)?;
        self.is_intake_active = true;
        Ok(())
    }

    /// Prints `s` at `row` of the grid.
    fn print_row(&mut self, row: UiUnit, s: &str, background_color: Option<Color>) -> Result<(), CommandError> {
        // Add 1 to account for header.
        queue!(self.out, MoveTo(0, row.saturating_add(1)))?;

        if let Some(color) = background_color {
            queue!(self.out, SetBackgroundColor(color))?;
        }

        queue!(self.out, Print(s), Clear(ClearType::UntilNewLine))?;

        if background_color.is_some() {
            queue!(self.out, ResetColor)?;
        }

        Ok(())
    }

    /// Removes all temporary boxes and re-displays the full grid.
    fn reset(&mut self) -> Result<(), CommandError> {
        if self.alert_rows != 0 {
            for (index, row) in Rows::new(&self.text.clone(), self.wrap_length()).take(self.alert_rows.into()).enumerate() {
                self.print_row(
                    UiUnit::try_from(index).unwrap(),
                    row.text,
                    None,
                )?;
            }

            self.alert_rows = 0;
        }

        if self.is_intake_active {
            let row = self.size.rows.saturating_sub(1);

            self.print_row(
                row,
                Rows::new(&self.text.clone(), self.wrap_length()).nth(row.into()).map(|row| row.text).unwrap_or_default(),
                None,
            )?;
            self.is_intake_active = false;
        }

        Ok(())
    }
}

impl Default for Body {
    fn default() -> Self {
        Self {
            out: io::stdout(),
            lines: Vec::new(),
            text: String::new(),
            alert_rows: 0,
            is_intake_active: false,
            // Start with a null Body, size will be read on startup and passed in as a Display.
            size: Size {
                rows: 0,
                columns: 0,
            },
            top_line: 0,
            is_wrapped: false,
        }
    }
}

#[derive(Clone, Debug, Default, PartialEq)]
pub(crate) struct Selection {
    range: Range,
}

impl Selection {
    pub(crate) const fn empty() -> Self {
        Selection {
            range: Range {
                start: Position {
                    line: 0,
                    character: 0,
                },
                end: Position {
                    line: 0,
                    character: 0,
                },
            },
        }
    }

    pub(crate) fn range(&self) -> Range {
        self.range
    }

    pub(crate) fn range_mut(&mut self) -> &mut Range {
        &mut self.range
    }

    pub(crate) fn move_down(&mut self, amount: u64, line_count: u64) {
        let end_line = cmp::min(self.range.end.line.saturating_add(amount), line_count);
        self.range.start.line = self.range.start.line.saturating_add(end_line.saturating_sub(self.range.end.line));
        self.range.end.line = end_line;
    }
    
    pub(crate) fn move_up(&mut self, amount: u64) {
        let start_line = self.range.start.line.saturating_sub(amount);
        self.range.end.line = self.range.end.line.saturating_sub(self.range.start.line.saturating_sub(start_line));
        self.range.start.line = start_line;
    }

    fn last_line(&self) -> u64 {
        let mut line = self.range.end.line;

        if self.range.end.character == 0 {
            line = line.saturating_sub(1);
        }

        line
    }
}

struct NewRows {
    lines: VecDeque<String>,
    max_len: UiUnit,
}

impl NewRows {
    pub(crate) fn new(lines: VecDeque<String>, max_len: UiUnit) -> Self {
        Self {
            lines,
            max_len,
        }
    }
}

impl Iterator for NewRows {
    type Item = String;

    fn next(&mut self) -> Option<Self::Item> {
        if let Some(mut line) = self.lines.pop_front() {
            let max_len = self.max_len.into();

            if line.len() > max_len {
                let new_line = line.split_off(max_len);
                self.lines.push_front(new_line);
            }

            Some(line)
        } else {
            None
        }
    }
}

/// An iterator that yields [`Row`]s from a string of text.
#[derive(Clone, Debug, PartialEq)]
struct Rows<'a> {
    /// The string of text.
    text: &'a str,
    /// The maximum allowed length of a row.
    max_len: UiUnit,
    /// The [`LineInfo`] for `text`.
    line_info: LineInfo,
}

impl<'a> Rows<'a> {
    /// Creates a new iterator that yields the [`Row`]s of `text` with `max_len`.
    pub(crate) fn new(text: &'a str, max_len: UiUnit) -> Self {
        Rows {
            text,
            max_len,
            line_info: LineInfo::new(text, 0),
        }
    }
}

impl<'a> Iterator for Rows<'a> {
    type Item = Row<'a>;

    fn next(&mut self) -> Option<Self::Item> {
        if self.text.is_empty() {
            None
        } else {
            let row_info = self.line_info.take_row_info(self.max_len);
            let (row_text, remainder) = self.text.split_at(usize::from(row_info.length.text));
            let (_, new_text) = remainder.split_at(row_info.length.newline);
            self.text = new_text;

            if row_info.is_end_of_line() {
                self.line_info.index = self.line_info.index.saturating_add(1);
                self.line_info = LineInfo::new(self.text, self.line_info.index);
            }

            Some(Row {
                text: row_text,
                line: row_info.index,
            })
        }
    }
}

/// A row of text in the user interface.
///
/// Facilitates wrapping long lines onto multiple rows.
#[derive(Clone, Debug)]
pub(crate) struct Row<'a> {
    /// The line index of the row.
    line: u64,
    /// The text of the row.
    text: &'a str,
}

#[derive(Clone, Debug, PartialEq)]
struct LineInfo {
    index: u64,
    length: LineLength,
}

impl LineInfo {
    fn new(text: &str, index: u64) -> Self {
        Self {
            index: index,
            length: if let Some(text_len) = text.find('\n') {
                let mut length = LineLength {
                    text: UiUnit::try_from(text_len).unwrap(),
                    newline: 1,
                };

                if let Some(line_end) = text_len.checked_sub(1) {
                    if text.get(line_end..=line_end) == Some("\r") {
                        length.text = UiUnit::try_from(line_end).unwrap();
                        length.newline = 2;
                    }
                }

                length
            } else {
                LineLength {
                    text: UiUnit::try_from(text.len()).unwrap(),
                    newline: 0,
                }
            },
        }
    }

    fn is_end_of_line(&self) -> bool {
        self.length.newline != 0
    }

    fn take_row_info(&mut self, max_len: UiUnit) -> Self {
        Self {
            index: self.index,
            length: if self.length.text > max_len {
                self.length.text = self.length.text.saturating_sub(max_len);
                LineLength {
                    text: max_len,
                    newline: 0,
                }
            } else {
                self.length.take()
            }
        }
    }
}

#[derive(Clone, Debug, PartialEq)]
struct LineLength {
    text: UiUnit,
    newline: usize,
}

impl LineLength {
    fn take(&mut self) -> Self {
        let length = self.clone();
        self.text = 0;
        self.newline = 0;
        length
    }
}

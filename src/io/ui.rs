//! Implements the interface between the user and the application.
//!
//! The user is able to provide input via any of the following methods:
//! - key press
//! - mouse event
//! - size change
//!
//! The application delivers the following output to the user via stdout of the command. Output is organized in the following visual manner:
//! - The first row of the screen is the header, which displays information generated by starship.
//! - All remaining space on the screen is primarily used for displaying the text of the currently viewed document.
//! - If the application needs to alert the user, it may do so via a message box that will temporarily overlap the top rows of the document.
//! - If the application requires input from the user, it may do so via an input box that will temporarily overlap the bottom rows of the document.
pub(crate) use crossterm::event::{KeyCode as Key, KeyModifiers as Modifiers};

use {
    core::{
        cmp,
        convert::TryFrom,
        fmt::{self, Debug},
        time::Duration,
        ops::{RangeBounds, Bound},
    },
    crossterm::{
        cursor::{Hide, MoveTo, RestorePosition, SavePosition},
        event::{self, Event},
        execute, queue,
        style::{Color, Print, ResetColor, SetBackgroundColor},
        terminal::{self, Clear, ClearType, EnterAlternateScreen, LeaveAlternateScreen},
        ErrorKind,
    },
    log::warn,
    lsp_types::{MessageType, Range, TextEdit, ShowMessageParams, ShowMessageRequestParams, Position},
    std::{
        collections::VecDeque,
        io::{self, Stdout, Write},
    },
    thiserror::Error,
};

/// A span of time that equal to no time.
static INSTANT: Duration = Duration::from_secs(0);

/// An error while executing or queueing a [`crossterm`] command.
///
/// [`crossterm`]: ../../crossterm/index.html
#[derive(Debug, Error)]
#[error("while executing or queueing a terminal command: {0}")]
pub struct CommandError(#[from] ErrorKind);

/// An error while flushing terminal output.
#[derive(Debug, Error)]
#[error("while flushing terminal output: {0}")]
pub struct FlushError(#[from] io::Error);

/// A user interface provided by a terminal.
pub(crate) struct Terminal {
    /// The output of the application.
    out: Stdout,
    /// The body of the screen, where all document text is displayed.
    body: Body,
}

#[allow(clippy::unused_self)] // For pull(), will be used when user interface becomes a trait.
impl Terminal {
    /// Returns the size of the terminal.
    pub(crate) fn size() -> Size {
        match terminal::size() {
            Ok((columns, rows)) => TerminalSize::new(rows, columns),
            Err(e) => {
                warn!("unable to retrieve size of terminal: {}", e);
                TerminalSize::default()
            }
        }.into()
    }

    /// Creates a new [`Terminal`].
    pub(crate) fn new() -> Result<Self, CommandError> {
        let mut term = Self {
            out: io::stdout(),
            body: Body::default(),
        };

        // Execute failable commands after creating Terminal so that it will be dropped on failure.
        execute!(term.out, EnterAlternateScreen, Hide)?;
        Ok(term)
    }

    /// Returns input from the user.
    ///
    /// [`None`] indicates there is no input from the user.
    pub(crate) fn pull(&self) -> Result<Option<Input>, CommandError> {
        Ok(if event::poll(INSTANT)? {
            Some(event::read()?.into())
        } else {
            None
        })
    }

    pub(crate) fn open_doc(&mut self, text: &str) -> Result<(), CommandError> {
        self.body.open(text)
    }
    
    pub(crate) fn wrap(&mut self, is_wrapped: bool, selection: &Selection) -> Result<(), CommandError> {
        self.body.is_wrapped = is_wrapped;
        self.body.refresh(selection)
    }

    pub(crate) fn edit(&mut self, edit: TextEdit, selection: &Selection) -> Result<(), CommandError> {
        self.body.edit(edit);
        self.body.refresh(selection)
    }
    
    pub(crate) fn move_selection(&mut self, selection: &Selection) -> Result<(), CommandError> {
        self.body.refresh(selection)
    }

    pub(crate) fn set_header(&mut self, header: String) -> Result<(), CommandError> {
        queue!(self.out, SavePosition, MoveTo(0, 0), Print(header), RestorePosition).map_err(|e| e.into())
    }

    pub(crate) fn notify(&mut self, message: ShowMessageParams) -> Result<(), CommandError> {
        self.body.add_alert(&message.message, message.typ)
    }
    
    pub(crate) fn question(&mut self, request: ShowMessageRequestParams) -> Result<(), CommandError> {
        // TODO: Add implementation to use actions.
        self.body.add_alert(&request.message, request.typ)
    }

    pub(crate) fn start_intake(&mut self, title: String) -> Result<(), CommandError> {
        self.body.add_intake(title)
    }

    pub(crate) fn reset(&mut self, selection: &Selection) -> Result<(), CommandError> {
        self.body.reset(selection)
    }

    pub(crate) fn resize(&mut self, size: Size) {
        self.body.size = size;
    }

    pub(crate) fn write(&mut self, ch: char) -> Result<(), CommandError> {
        queue!(self.out, Print(ch)).map_err(|e| e.into())
    }

    /// Flushes the terminal output.
    pub(crate) fn flush(&mut self) -> Result<(), FlushError> {
        self.out.flush().map_err(|e| e.into())
    }
}

impl Debug for Terminal {
    fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {
        write!(f, "Terminal")
    }
}

impl Drop for Terminal {
    fn drop(&mut self) {
        if execute!(self.out, LeaveAlternateScreen).is_err() {
            warn!("Failed to leave alternate screen");
        }
    }
}

/// Input generated by the user.
#[derive(Debug)]
pub(crate) enum Input {
    /// The space available for display has been resized.
    ///
    /// The parameter is the new size of the body.
    #[allow(dead_code)] // False positive.
    Resize(Size),
    /// A mouse event has occurred.
    Mouse,
    /// A key has been pressed.
    #[allow(dead_code)] // False positive.
    Key {
        /// The keycode of the key.
        key: Key,
        /// All modifier keys that were held when the key was pressed.
        modifiers: Modifiers,
    },
}

impl From<Event> for Input {
    fn from(value: Event) -> Self {
        match value {
            Event::Resize(columns, rows) => Self::Resize(TerminalSize::new(rows, columns).into()),
            Event::Mouse(..) => Self::Mouse,
            Event::Key(key) => Self::Key {
                key: key.code,
                modifiers: key.modifiers,
            },
        }
    }
}

impl From<Size> for Input {
    fn from(value: Size) -> Self {
        Self::Resize(value)
    }
}

/// The dimensions of a grid of [`char`]s.
#[derive(Clone, Debug, Default, Eq, PartialEq)]
pub(crate) struct Size {
    /// The number of rows.
    pub(crate) rows: UiUnit,
    /// The number of columns.
    pub(crate) columns: UiUnit,
}

impl From<TerminalSize> for Size {
    fn from(value: TerminalSize) -> Self {
        Size {
            // Account for header in first row.
            rows: value.0.rows.saturating_sub(1),
            // Windows command prompt does not print a character in the last reported column.
            columns: value.0.columns.saturating_sub(1),
        }
    }
}

/// The [`Size`] of the terminal.
struct TerminalSize(Size);

impl TerminalSize {
    fn new(rows: UiUnit, columns: UiUnit) -> Self {
        Self(Size{rows, columns})
    }
}

impl Default for TerminalSize {
    /// Returns the default size for a terminal: 20x80.
    fn default() -> Self {
        Self::new(20, 80)
    }
}

/// The type the user interface uses.
type UiUnit = u16;

/// The part of the output that displays the content of the document.
#[derive(Default)]
struct Body {
    /// Prints the output.
    printer: Printer,
    /// Holds the current lines of the document.
    lines: Vec<String>,
    /// The number of rows currently covered by an alert.
    alert_rows: UiUnit,
    /// If the intake box is current active.
    is_intake_active: bool,
    /// The size of the body.
    size: Size,
    /// The index of the first line of the document to be displayed.
    top_line: u64,
    /// If the text is wrapped.
    is_wrapped: bool,
}

impl Body {
    /// Sets `text` and prints it.
    fn open(&mut self, text: &str) -> Result<(), CommandError> {
        self.lines = text.lines().map(|line| line.to_string()).collect();
        self.refresh(&Selection::default())
    }

    /// Returns the length at which a line will be wrapped.
    fn wrap_length(&self) -> UiUnit {
        if self.is_wrapped {
            self.size.columns
        } else {
            UiUnit::max_value()
        }
    }

    /// Modifies `self` according to `edit`.
    fn edit(&mut self, edit: TextEdit) {
        let _ = self.lines.splice(Selection::new(edit.range), edit.new_text.lines().map(|line| line.to_string()));
    }

    /// Prints all of `self` with `selection` marked.
    fn refresh(&mut self, selection: &Selection) -> Result<(), CommandError> {
        if selection.range.start.line < self.top_line {
            self.top_line = selection.range.start.line;
        }

        let first_line = self.top_line;
        let last_line = selection.last_line();
        let mut rows = Rows::new(&self.lines, self.wrap_length()).skip_while(|row| row.line < first_line);
        let mut visible_rows = VecDeque::new();

        for _ in 0..self.size.rows.into() {
            if let Some(row) = rows.next() {
                visible_rows.push_back(row);
            }
        }

        while let Some(row) = rows.next() {
            if visible_rows.front().map(|r| r.line) != Some(self.top_line) {
                let _ = visible_rows.pop_front();
                visible_rows.push_back(row);
            } else if last_line < row.line {
                break;
            } else {
                self.top_line = self.top_line.saturating_add(1);
                let _ = visible_rows.pop_front();
                visible_rows.push_back(row);
            }
        }

        self.printer.print_rows(visible_rows.iter(), Context::Document{selected_line: last_line})
    }

    /// Adds an alert box over the grid.
    fn add_alert(&mut self, message: &str, context: MessageType) -> Result<(), CommandError> {
        for line in message.lines() {
            self.print_row(
                self.alert_rows,
                line,
                Some(match context {
                    MessageType::Error => Color::Red,
                    MessageType::Warning => Color::Yellow,
                    MessageType::Info => Color::Blue,
                    MessageType::Log => Color::DarkCyan,
                }),
            )?;
            self.alert_rows = self.alert_rows.saturating_add(1);
        }

        Ok(())
    }

    /// Adds an input box beginning with `prompt`
    fn add_intake(&mut self, mut prompt: String) -> Result<(), CommandError> {
        prompt.push_str(": ");
        self.printer.print_row(self.size.rows.saturating_sub(1), &Row {
            text: &prompt,
            line: 0,
        }, &Context::Box)?;
        self.is_intake_active = true;
        Ok(())
    }

    /// Prints `s` at `row` of the grid.
    fn print_row(&mut self, row: UiUnit, s: &str, background_color: Option<Color>) -> Result<(), CommandError> {
        // Add 1 to account for header.
        queue!(self.printer.out, MoveTo(0, row.saturating_add(1)))?;

        if let Some(color) = background_color {
            queue!(self.printer.out, SetBackgroundColor(color))?;
        }

        queue!(self.printer.out, Print(s), Clear(ClearType::UntilNewLine))?;

        if background_color.is_some() {
            queue!(self.printer.out, ResetColor)?;
        }

        Ok(())
    }

    /// Removes all temporary boxes and re-displays the full grid.
    fn reset(&mut self, selection: &Selection) -> Result<(), CommandError> {
        if self.alert_rows != 0 {
            for (index, row) in Rows::new(&self.lines, self.wrap_length()).take(self.alert_rows.into()).enumerate() {
                self.printer.print_row(
                    UiUnit::try_from(index).unwrap(),
                    &row,
                    &Context::Document { selected_line: selection.last_line()},
                )?;
            }

            self.alert_rows = 0;
        }

        if self.is_intake_active {
            let row = self.size.rows.saturating_sub(1);

            self.printer.print_row(
                row,
                &Rows::new(&self.lines, self.wrap_length()).nth(row.into()).unwrap_or_default(),
                &Context::Document{selected_line: selection.last_line()},
            )?;
            self.is_intake_active = false;
        }

        Ok(())
    }
}

enum Context {
    Document {
        selected_line: u64,
    },
    Box,
}

// This serves to separate the [`Stdout`] from the rest of the [`Body`] so that it can be `mut`.
struct Printer {
    out: Stdout,
}

impl Printer {
    fn print_row<'a>(&mut self, index: UiUnit, row: &Row<'a>, context: &Context) -> Result<(), CommandError> {
        let mut did_change_color = false;
        // Add 1 to account for header.
        queue!(self.out, MoveTo(0, index.saturating_add(1)))?;

        match context {
            Context::Document { selected_line } => {
                if row.line == *selected_line {
                    queue!(self.out, SetBackgroundColor(Color::DarkGrey))?;
                    did_change_color = true;
                }
            }
            Context::Box => {}
        }

        queue!(self.out, Print(row.text), Clear(ClearType::UntilNewLine))?;

        if did_change_color {
            queue!(self.out, ResetColor)?;
        }

        Ok(())
    }

    fn print_rows<'a>(&mut self, rows: impl Iterator<Item=&'a Row<'a>>, context: Context) -> Result<(), CommandError> {
        for (index, row) in rows
            .enumerate()
        {
            self.print_row(UiUnit::try_from(index).expect("retrieving `UiUnit` from usize"), row, &context)?;
        }

        queue!(self.out, Clear(ClearType::FromCursorDown)).map_err(|e| e.into())
    }
}

impl Default for Printer {
    fn default() -> Self {
        Self {
            out: io::stdout(),
        }
    }
}

#[derive(Clone, Debug, Default, PartialEq)]
pub(crate) struct Selection {
    range: Range,
    start_line: usize,
    end_line: usize,
}

impl Selection {
    fn new(range: Range) -> Self {
        Self {
            range,
            start_line: usize::try_from(range.start.line).unwrap(),
            end_line: usize::try_from(range.end.line).unwrap(),
        }
    }

    pub(crate) const fn empty() -> Self {
        Selection {
            range: Range {
                start: Position {
                    line: 0,
                    character: 0,
                },
                end: Position {
                    line: 0,
                    character: 0,
                },
            },
            start_line: 0,
            end_line: 0,
        }
    }

    pub(crate) fn range(&self) -> Range {
        self.range
    }

    pub(crate) fn range_mut(&mut self) -> &mut Range {
        &mut self.range
    }

    pub(crate) fn move_down(&mut self, amount: u64, line_count: u64) {
        let end_line = cmp::min(self.range.end.line.saturating_add(amount), line_count);
        self.range.start.line = self.range.start.line.saturating_add(end_line.saturating_sub(self.range.end.line));
        self.range.end.line = end_line;
    }
    
    pub(crate) fn move_up(&mut self, amount: u64) {
        let start_line = self.range.start.line.saturating_sub(amount);
        self.range.end.line = self.range.end.line.saturating_sub(self.range.start.line.saturating_sub(start_line));
        self.range.start.line = start_line;
    }

    fn last_line(&self) -> u64 {
        let mut line = self.range.end.line;

        if self.range.end.character == 0 {
            line = line.saturating_sub(1);
        }

        line
    }
}

impl RangeBounds<usize> for Selection {
    fn start_bound(&self) -> Bound<&usize> {
        Bound::Included(&self.start_line)
    }

    fn end_bound(&self) -> Bound<&usize> {
        Bound::Excluded(&self.end_line)
    }
}

#[derive(Clone)]
struct Rows<'a> {
    lines: &'a Vec<String>,
    max_len: usize,
    row: usize,
    line: u64,
    index: usize,
}

impl<'a> Rows<'a> {
    pub(crate) fn new(lines: &'a Vec<String>, max_len: UiUnit) -> Self {
        Self {
            lines,
            max_len: max_len.into(),
            row: 0,
            line: 0,
            index: 0,
        }
    }
}

impl<'a> Iterator for Rows<'a> {
    type Item = Row<'a>;

    fn next(&mut self) -> Option<Self::Item> {
        if let Some(line_text) = self.lines.get(usize::try_from(self.line).unwrap()) {
            let row_len = line_text.len() - self.index;
            let row = Row {
                line: self.line,
                text: if row_len > self.max_len {
                    let start = self.index;
                    self.index += self.max_len;
                    line_text.get(start..self.index).expect("getting text for row")
                } else {
                    let start = self.index;
                    self.line += 1;
                    self.index = 0;
                    line_text.get(start..).unwrap()
                },
            };

            self.row += 1;
            Some(row)
        } else {
            None
        }
    }
}

#[derive(Debug, Default)]
struct Row<'a> {
    line: u64,
    text: &'a str,
}

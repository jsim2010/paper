//! Implements the interface between the user and the application.
//!
//! The user is able to provide input via any of the following methods:
//! - key press
//! - mouse event
//! - size change
//!
//! The application delivers the following output to the user via stdout of the command. Output is organized in the following visual manner:
//! - The first row of the screen is the header, which displays information generated by starship.
//! - All remaining space on the screen is primarily used for displaying the text of the currently viewed document.
//! - If the application needs to alert the user, it may do so via a message box that will temporarily overlap the top rows of the document.
//! - If the application requires input from the user, it may do so via an input box that will temporarily overlap the bottom rows of the document.
pub(crate) use crossterm::event::{KeyCode as Key, KeyModifiers as Modifiers};

use {
    core::{
        convert::TryFrom,
        fmt::{self, Debug},
        time::Duration,
    },
    crossterm::{
        cursor::{Hide, MoveTo, RestorePosition, SavePosition},
        event::{self, Event},
        execute, queue,
        style::{Color, Print, ResetColor, SetBackgroundColor},
        terminal::{self, Clear, ClearType, EnterAlternateScreen, LeaveAlternateScreen},
        ErrorKind,
    },
    log::{trace, warn},
    lsp_types::{MessageType, Range, ShowMessageParams, ShowMessageRequestParams},
    std::{
        io::{self, Stdout, Write},
    },
    thiserror::Error,
};

/// A span of time that equal to no time.
static INSTANT: Duration = Duration::from_secs(0);

/// An error while executing or queueing a [`crossterm`] command.
///
/// [`crossterm`]: ../../crossterm/index.html
#[derive(Debug, Error)]
#[error("while executing or queueing a terminal command: {0}")]
pub struct CommandError(#[from] ErrorKind);

/// An error while flushing terminal output.
#[derive(Debug, Error)]
#[error("while flushing terminal output: {0}")]
pub struct FlushError(#[from] io::Error);

/// A user interface provided by a terminal.
pub(crate) struct Terminal {
    /// The output of the application.
    out: Stdout,
    /// The body of the screen, where all document text is displayed.
    body: Body,
}

#[allow(clippy::unused_self)] // For pull(), will be used when user interface becomes a trait.
impl Terminal {
    /// Creates a new [`Terminal`].
    pub(crate) fn new() -> Result<Self, CommandError> {
        let mut term = Self {
            out: io::stdout(),
            body: Body::default(),
        };

        // Execute failable commands after creating Terminal so that it will be dropped on failure.
        execute!(term.out, EnterAlternateScreen, Hide)?;
        Ok(term)
    }

    /// Returns input from the user.
    ///
    /// [`None`] indicates there is no input from the user.
    pub(crate) fn pull(&self) -> Result<Option<Input>, CommandError> {
        Ok(if event::poll(INSTANT)? {
            Some(event::read()?.into())
        } else {
            None
        })
    }

    /// Applies `display` to the terminal output pipeline.
    ///
    /// It is not guaranteed that all outputs have been displayed until [`Terminal::flush()`] has been called.
    pub(crate) fn push(&mut self, display: Display<'_>) -> Result<(), CommandError> {
        match display {
            Display::Header(header) => {
                queue!(self.out, SavePosition, MoveTo(0, 0), Print(header), RestorePosition)?;
            }
            Display::Body { rows, selection } => {
                self.body.print(rows, selection)?;
            }
            Display::Message(alert) => {
                self.body.add_alert(&alert.message, alert.typ)?;
            }
            Display::Question(question) => {
                // TODO: Add implementation to use actions.
                self.body.add_alert(&question.message, question.typ)?;
            }
            Display::Reset => {
                self.body.reset()?;
            }
            Display::Intake(title) => {
                self.body.add_intake(title)?;
            }
            Display::Resize(size) => {
                self.body.resize(size.rows);
            }
            Display::Char(c) => {
                queue!(self.out, Print(c))?;
            }
        }

        Ok(())
    }

    /// Flushes the terminal output.
    pub(crate) fn flush(&mut self) -> Result<(), FlushError> {
        self.out.flush().map_err(|e| e.into())
    }
}

impl Debug for Terminal {
    fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {
        write!(f, "Terminal")
    }
}

impl Drop for Terminal {
    fn drop(&mut self) {
        if execute!(self.out, LeaveAlternateScreen).is_err() {
            warn!("Failed to leave alternate screen");
        }
    }
}

/// Input generated by the user.
#[derive(Debug)]
pub(crate) enum Input {
    /// The space available for display has been resized.
    ///
    /// The parameter is the new size of the body.
    #[allow(dead_code)] // False positive.
    Resize(Size),
    /// A mouse event has occurred.
    Mouse,
    /// A key has been pressed.
    #[allow(dead_code)] // False positive.
    Key {
        /// The keycode of the key.
        key: Key,
        /// All modifier keys that were held when the key was pressed.
        modifiers: Modifiers,
    },
}

impl From<Event> for Input {
    fn from(value: Event) -> Self {
        match value {
            Event::Resize(columns, rows) => TerminalSize{ rows, columns }.into(),
            Event::Mouse(..) => Self::Mouse,
            Event::Key(key) => Self::Key {
                key: key.code,
                modifiers: key.modifiers,
            },
        }
    }
}

impl From<TerminalSize> for Input {
    fn from(value: TerminalSize) -> Self {
        Self::Resize(Size {
            // Account for header in first row.
            rows: value.rows.saturating_sub(1),
            // Windows command prompt does not print a character in the last reported column.
            columns: value.columns.saturating_sub(1),
        })
    }
}

/// A modification to the user display.
#[derive(Clone, Debug, PartialEq)]
pub(crate) enum Display<'a> {
    /// Set the header.
    Header(String),
    /// Set the body.
    Body {
        /// The rows of the current document.
        rows: Rows<'a>,
        /// The range of the current selection.
        selection: Range,
    },
    /// Add a message over the top rows of the body.
    Message(ShowMessageParams),
    /// Add a message over the top rows of the body and request a response.
    Question(ShowMessageRequestParams),
    /// Clear items on top of the body.
    Reset,
    /// Add an intake box that starts with the given prompt.
    Intake(String),
    /// Resize the terminal to accomodate a body of the given size.
    Resize(Size),
    /// Write a [`char`] to the current cursor location.
    Char(char),
}

/// The dimensions of a grid of [`char`]s.
#[derive(Clone, Debug, Eq, PartialEq)]
pub(crate) struct Size {
    /// The number of rows.
    pub(crate) rows: u16,
    /// The number of columns.
    pub(crate) columns: u16,
}

pub(crate) type TerminalSize = Size;

impl TerminalSize {
    /// Returns the size of the terminal.
    pub(crate) fn get() -> Self {
        match terminal::size() {
            Ok((columns, rows)) => Self {rows, columns},
            Err(e) => {
                warn!("unable to retrieve size of terminal: {}", e);
                Self::default()
            }
        }
    }
}

impl Default for TerminalSize {
    /// Returns the default size for a terminal: 20x80.
    fn default() -> Self {
        Self {
            rows: 20,
            columns: 80,
        }
    }
}

/// A row of text in the user interface.
///
/// Facilitates wrapping long lines onto multiple rows.
#[derive(Clone, Debug)]
pub(crate) struct Row<'a> {
    /// The line index of the row.
    line: u64,
    /// The text of the row.
    text: &'a str,
}

/// An iterator that yields [`Row`]s from a string of text.
#[derive(Clone, Debug, PartialEq)]
pub(crate) struct Rows<'a> {
    /// The string of text.
    text: &'a str,
    /// The maximum allowed length of a row.
    max_len: usize,
    /// The [`LineInfo`] for `text`.
    line_info: LineInfo,
}

impl<'a> Rows<'a> {
    /// Creates a new iterator that yields the [`Row`]s of `text` with `max_len`.
    ///
    /// Assumes that `text` is the full document starting at line index 0.  Setting `max_len` to [`None`] indicates there is no maximum allowed length.
    pub(crate) fn new(text: &'a str, max_len: Option<usize>) -> Self {
        Rows {
            text,
            max_len: max_len.unwrap_or(usize::max_value()),
            line_info: LineInfo::new(text, 0),
        }
    }
}

impl<'a> Iterator for Rows<'a> {
    type Item = Row<'a>;

    fn next(&mut self) -> Option<Self::Item> {
        if self.text.is_empty() {
            None
        } else {
            let row_info = self.line_info.take_row_info(self.max_len);
            let (row_text, remainder) = self.text.split_at(row_info.length.text);
            let (_, new_text) = remainder.split_at(row_info.length.newline);
            self.text = new_text;

            if row_info.is_end_of_line() {
                self.line_info.index = self.line_info.index.saturating_add(1);
                self.line_info = LineInfo::new(self.text, self.line_info.index);
            }

            Some(Row {
                text: row_text,
                line: row_info.index,
            })
        }
    }
}

/// The part of the output that displays the content of the document.
struct Body {
    /// The output of the application.
    out: Stdout,
    /// The rows of text displayed by the body.
    rows: Vec<String>,
    /// The number of rows currently covered by an alert.
    alert_rows: u16,
    /// If the intake box is current active.
    is_intake_active: bool,
    /// The total number of rows.
    height: u16,
    /// The index of the first line of the document to be displayed.
    top_line: u64,
}

impl Body {
    /// Resizes grid to have `height` number of rows.
    fn resize(&mut self, height: u16) {
        for _ in self.height..height {
            self.rows.push(String::default());
        }

        self.height = height;
    }

    fn print(&mut self, rows: Rows<'_>, selection: Range) -> Result<(), CommandError> {
        if selection.start.line < self.top_line {
            self.top_line = selection.start.line;
        }

        let mut visible_rows: Vec<Row<'_>> = rows
            .clone()
            .filter(|row| row.line >= self.top_line)
            .collect();
        let mut end_line = selection.end.line;

        if selection.end.character == 0 {
            end_line = end_line.saturating_sub(1);
        }

        while let Some(first_line_past_bottom) = visible_rows
            .get(usize::from(self.height))
            .map(|row| row.line)
        {
            if end_line < first_line_past_bottom {
                break;
            } else {
                let line = visible_rows.remove(0).line;
                self.top_line = self.top_line.saturating_add(1);

                while visible_rows.get(0).map(|row| row.line) == Some(line) {
                    let _ = visible_rows.remove(0);
                }
            }
        }

        let top_line = self.top_line;

        for (index, row) in rows
            .filter(|row| row.line >= top_line)
            .enumerate()
            .take(usize::from(self.height))
        {
            self.replace_line(index, row.text, row.line == end_line)?;
        }

        queue!(self.out, Clear(ClearType::FromCursorDown)).map_err(|e| e.into())
    }

    /// Replaces line in grid at `index` with `new_line`.
    fn replace_line(&mut self, index: usize, new_line: &str, is_cursor_line: bool) -> Result<(), CommandError> {
        trace!("replace_line {}", new_line);
        if let Some(line) = self.rows.get_mut(index) {
            line.replace_range(.., new_line);
        }

        self.print_row(
            u16::try_from(index).unwrap_or(u16::max_value()),
            new_line,
            if is_cursor_line {
                Some(Color::DarkGrey)
            } else {
                None
            },
        )
    }

    /// Adds an alert box over the grid.
    fn add_alert(&mut self, message: &str, context: MessageType) -> Result<(), CommandError> {
        for line in message.lines() {
            self.print_row(
                self.alert_rows,
                line,
                Some(match context {
                    MessageType::Error => Color::Red,
                    MessageType::Warning => Color::Yellow,
                    MessageType::Info => Color::Blue,
                    MessageType::Log => Color::DarkCyan,
                }),
            )?;
            self.alert_rows = self.alert_rows.saturating_add(1);
        }

        Ok(())
    }

    /// Adds an input box beginning with `prompt`
    fn add_intake(&mut self, mut prompt: String) -> Result<(), CommandError> {
        prompt.push_str(": ");
        self.print_row(self.height.saturating_sub(1), &prompt, None)?;
        self.is_intake_active = true;
        Ok(())
    }

    /// Prints `s` at `row` of the grid.
    fn print_row(&mut self, row: u16, s: &str, background_color: Option<Color>) -> Result<(), CommandError> {
        // Add 1 to account for header.
        queue!(self.out, MoveTo(0, row.saturating_add(1)))?;

        if let Some(color) = background_color {
            queue!(self.out, SetBackgroundColor(color))?;
        }

        queue!(self.out, Print(s), Clear(ClearType::UntilNewLine))?;

        if background_color.is_some() {
            queue!(self.out, ResetColor)?;
        }

        Ok(())
    }

    /// Removes all temporary boxes and re-displays the full grid.
    fn reset(&mut self) -> Result<(), CommandError> {
        if self.alert_rows != 0 {
            for row in 0..self.alert_rows {
                self.print_row(
                    row,
                    &self
                        .rows
                        .get(usize::from(row))
                        .cloned()
                        .unwrap_or_default(),
                    None,
                )?;
            }

            self.alert_rows = 0;
        }

        if self.is_intake_active {
            let row = self.height.saturating_sub(1);

            self.print_row(
                row,
                &self
                    .rows
                    .get(usize::from(row))
                    .cloned()
                    .unwrap_or_default(),
                None,
            )?;
            self.is_intake_active = false;
        }

        Ok(())
    }
}

impl Default for Body {
    fn default() -> Self {
        Self {
            out: io::stdout(),
            rows: Vec::default(),
            alert_rows: 0,
            is_intake_active: false,
            height: 0,
            top_line: 0,
        }
    }
}

#[derive(Clone, Debug, PartialEq)]
struct LineInfo {
    index: u64,
    length: LineLength,
}

impl LineInfo {
    fn new(text: &str, index: u64) -> Self {
        Self {
            index: index,
            length: if let Some(text_len) = text.find('\n') {
                let mut length = LineLength {
                    text: text_len,
                    newline: 1,
                };

                if let Some(line_end) = text_len.checked_sub(1) {
                    if text.get(line_end..=line_end) == Some("\r") {
                        length.text = line_end;
                        length.newline = 2;
                    }
                }

                length
            } else {
                LineLength {
                    text: text.len(),
                    newline: 0,
                }
            },
        }
    }

    fn is_end_of_line(&self) -> bool {
        self.length.newline != 0
    }

    fn take_row_info(&mut self, max_len: usize) -> Self {
        Self {
            index: self.index,
            length: if self.length.text > max_len {
                self.length.text = self.length.text.saturating_sub(max_len);
                LineLength {
                    text: max_len,
                    newline: 0,
                }
            } else {
                self.length.take()
            }
        }
    }
}

#[derive(Clone, Debug, PartialEq)]
struct LineLength {
    text: usize,
    newline: usize,
}

impl LineLength {
    fn take(&mut self) -> Self {
        let length = self.clone();
        self.text = 0;
        self.newline = 0;
        length
    }
}

//! Implements the logging functionality of `paper`.
use {
    chrono::Local,
    fehler::throws,
    log::{LevelFilter, Log, Metadata, Record, SetLoggerError},
    std::{
        fs::File,
        io::{self, Write},
        sync::{Arc, RwLock},
    },
    structopt::StructOpt,
};

/// An error initializing the logger.
#[derive(Debug, thiserror::Error)]
pub enum InitLoggerError {
    /// An error creating the logger.
    #[error(transparent)]
    Create(#[from] CreateLoggerError),
    /// An error setting the logger.
    #[error("Failed to set logger: {0}")]
    Set(#[from] SetLoggerError),
}

/// An error creating a [`Logger`].
#[derive(Debug, thiserror::Error)]
#[error("Failed to create log file `{file}`: {error}")]
pub struct CreateLoggerError {
    /// The path of the log file.
    file: String,
    /// The error.
    #[source]
    error: io::Error,
}

/// Parses a [`LevelFilter`] from the number of occurrences of the verbose flag.
const fn parse_log_level(occurrences: u64) -> LevelFilter {
    match occurrences {
        0 => LevelFilter::Warn,
        1 => LevelFilter::Info,
        2 => LevelFilter::Debug,
        _ => LevelFilter::Trace,
    }
}

/// The configuration of the application logger.
#[derive(Clone, Debug, StructOpt)]
pub struct LogConfig {
    /// Enables logs for components.
    #[structopt(long("log"), value_name("COMPONENT"), require_equals(true), possible_values(&["starship"]))]
    components: Option<Vec<LogComponent>>,
    /// Increases the logging verbosity - can be repeated upto 3 times.
    #[structopt(short("v"), parse(from_occurrences = parse_log_level))]
    level: LevelFilter,
}

impl Default for LogConfig {
    #[inline]
    fn default() -> Self {
        Self {
            components: None,
            level: LevelFilter::Warn,
        }
    }
}

/// Components that log records.
#[derive(Clone, Debug, parse_display::FromStr, PartialEq)]
enum LogComponent {
    /// The `starship` component.
    Starship,
}

/// Creates and initializes a [`Logger`].
#[throws(InitLoggerError)]
pub(crate) fn init(config: LogConfig) {
    let logger = Logger::new(config.components.unwrap_or_default())?;

    log::set_boxed_logger(Box::new(logger))?;
    log::set_max_level(config.level);
    log::info!("Logger initialized");
}

/// Records all logs generated by the application.
struct Logger {
    /// The file to which logs shall be recorded.
    file: Arc<RwLock<File>>,
    /// The components that will be logged.
    components: Vec<LogComponent>,
}

impl Logger {
    /// Creates a [`Logger`] that logs records generated by the application and `components`.
    #[throws(CreateLoggerError)]
    fn new(components: Vec<LogComponent>) -> Self {
        let log_filename = "paper.log".to_string();

        Self {
            file: Arc::new(RwLock::new(File::create(&log_filename).map_err(
                |error| CreateLoggerError {
                    file: log_filename,
                    error,
                },
            )?)),
            components,
        }
    }
}

impl Log for Logger {
    fn enabled(&self, metadata: &Metadata<'_>) -> bool {
        if metadata.target().starts_with("starship") {
            self.components.contains(&LogComponent::Starship)
        } else {
            true
        }
    }

    fn log(&self, record: &Record<'_>) {
        if self.enabled(record.metadata()) {
            if let Ok(mut file) = self.file.write() {
                #[allow(unused_must_use)] // Log::log() does not propagate errors.
                {
                    writeln!(
                        file,
                        "{} [{}]: {}",
                        Local::now().format("%F %T"),
                        record.level(),
                        record.args()
                    );
                }
            }
        }
    }

    fn flush(&self) {
        if let Ok(mut file) = self.file.write() {
            #[allow(unused_must_use)] // Log::flush() does not propagate errors.
            {
                file.flush();
            }
        }
    }
}
